ENTRIES = (-1,0,1)

## takes a row vector with entries in {0, 1, -1} and returns True if `vec` is alternating ##
def isalt(vec):
    sum = 0
    
    for entry in vec:
        if entry not in ENTRIES:
            return False
        sum += entry
        if sum < 0 or sum > 1:
            return False
    
    if sum == 1:
        return True
    return False

## recursively generates all n-vectors with entries over ENTRIES, returns as a list `rows` ##
def genrow(n, rows=[], vec=[]):
    if n:
        for entry in ENTRIES:
            genrow(n-1, rows, vec+[entry])
    elif isalt(vec):
        rows.append(vec)
    return rows

## extracts the jth column from a matrix `mat` ##
def getcol(mat, j):
    col = []
    for i in range(len(mat)):
        col.append(mat[i][j])
    return col

## checks all columns in a given matrix are alternating ##
def matalt(mat):
    for j in range(len(mat)):
        col = getcol(mat,j)
        if not isalt(col):
            return False
    return True

## generates alternating sign matrices ##
def asm(n, allowed_rows, matrices=[], mat=[]):
    if n:
        for row in allowed_rows:
            asm(n-1, allowed_rows, matrices, mat+[row])
    elif matalt(mat):
        matrices.append(mat)
    return matrices

## takes the transpose of a matrix ##
def transpose(mat):
    tmat = []
    for j in range(len(mat)):
        tmat.append(getcol(mat,j))
    return tmat

## filters a list of matrices for diagonal symmetry ##
def disymm(matrices):
    diag = []
    for mat in matrices:
        if mat == transpose(mat):
            diag.append(mat)
    return diag

## enumerates asms ##
def enum(m):
    ASMs = asm(m, genrow(m))
    num = len(ASMs)
    dnum = len(disymm(ASMs))
    return m, num, dnum

## the enumeration generated by this script is consistant with sequence A005163 on the OEIS ##